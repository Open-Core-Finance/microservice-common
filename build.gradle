import java.net.HttpURLConnection
import java.nio.file.Files
import groovy.json.JsonSlurper

/**
 * Define build script dependencies.
 */
buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        dependencies {
            classpath("org.springframework.boot:spring-boot-gradle-plugin:$springBootPluginVersion")
        }
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:$springBootPluginVersion")
        classpath "io.spring.gradle:dependency-management-plugin:$springDependenciesManagementVersion"
        classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:latest.release"
        classpath "io.freefair.gradle:lombok-plugin:latest.release"
    }
}

plugins {
    id 'org.springframework.boot' version "$springBootPluginVersion" apply false
    id 'io.spring.dependency-management' version "$springDependenciesManagementVersion" apply false
    id "io.freefair.lombok" version "${lombokPluginVersion}" apply false
    id "org.sonarqube" version "${sonarqubePluginVersion}" apply false
    id("org.hibernate.orm") version "${hibernatePluginVersion}" apply false
}

// Include credential if any.
if (new File("artifact-credential.gradle").exists()) {
    apply from: 'artifact-credential.gradle'
} else {
    apply from: 'artifact-credential-sample.gradle'
}


def publishOutputFolder="publish-output"
def listJavaLibrariesProject = [
        "microservice-common", "microservice-common-jpa", "microservice-common-mongodb",
        "common-account", "common-product", "common-feign-client", "common-kafka", "common-userprofile",
        "microservice-common-export"
]

configure(subprojects) {
    buildscript {
        repositories {
            mavenLocal()
            mavenCentral()
            dependencies {
                classpath("org.springframework.boot:spring-boot-gradle-plugin:$springBootPluginVersion")
            }
        }
        dependencies {
            classpath("org.springframework.boot:spring-boot-gradle-plugin:$springBootPluginVersion")
            classpath "io.spring.gradle:dependency-management-plugin:$springDependenciesManagementVersion"
            classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:latest.release"
            classpath "io.freefair.gradle:lombok-plugin:latest.release"
        }
    }

    def isLib = false;
    for (def libPro : listJavaLibrariesProject) {
        if (libPro == project.name) {
            isLib = true;
            break;
        }
    }

    // Sub projects plugin
    apply plugin: 'io.spring.dependency-management'
    if (!isLib) {
        apply plugin: 'org.springframework.boot'
    }
    apply plugin: 'java-library'
    apply plugin: 'jacoco'
    apply plugin: 'application'
    apply plugin: 'io.freefair.lombok'
    apply plugin: 'org.sonarqube'
    apply plugin: 'maven-publish'
    apply plugin: 'signing'
    apply plugin: 'org.hibernate.orm'

    // Sub projects version
    group = "${applicationGroup}"
    version = "${applicationVersion}"

    // Sub projects java version
    java {
        toolchain {
            languageVersion.set(JavaLanguageVersion.of(javaSourceCompatibility))
        }
    }

    // Sub projects repositories
    repositories {
        mavenLocal()
        mavenCentral()
        maven {
            url = "https://s01.oss.sonatype.org/content/groups/public/"
        }
        maven {
            url = "https://packages.confluent.io/maven/"
        }
    }

    // Sub projects dependencies management
    dependencyManagement {
        imports {
            mavenBom "org.springframework.boot:spring-boot-dependencies:$springBootPluginVersion"
            mavenBom org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES
            mavenBom "org.springframework.cloud:spring-cloud-dependencies:$springCloudDependenciesVersion"
        }
    }

    // Sub projects jar config
    jar {
        archiveClassifier = ""
        exclude("*.der")
        exclude("*.xml")
        exclude("*.yaml")
        exclude("db")
        exclude("resources")
        exclude("**/*Application.class")
    }

    if (project.hasProperty('bootJar')) {
        bootJar {
            archiveClassifier = "boot"
            enabled = true
        }
    }

    jacoco {
        toolVersion = "${jacocoToolVersion}"
        reportsDirectory = layout.buildDirectory.dir("jacoco").get()
    }

    test {
        useJUnitPlatform()

        // report is always generated after tests run
        finalizedBy jacocoTestReport

        jacoco {
            classDumpDir = layout.buildDirectory.file("jacoco/classpathdumps").get().asFile
            enabled = true
            destinationFile = layout.buildDirectory.file("jacoco/${name}.exec").get().asFile
            includes = []
            excludes = []
            excludeClassLoaders = []
            includeNoLocationClasses = false
            sessionId = UUID.randomUUID().toString()
            dumpOnExit = true
            classDumpDir = null
            output = JacocoTaskExtension.Output.FILE
            address = "localhost"
            port = 6300
            jmx = false
        }
    }

    jacocoTestReport {
        // tests are required to run before generating the report
        dependsOn test
        mustRunAfter test

        reports {
            html.required = true
            xml.required = true
            csv.required = true
            html.outputLocation = layout.buildDirectory.dir("jacoco/html").get().asFile
            xml.outputLocation = layout.buildDirectory.file("jacoco/jacoco-report.xml").get().asFile
            csv.outputLocation = layout.buildDirectory.file("jacoco/jacoco-report.csv").get().asFile
        }

        afterEvaluate {
            getClassDirectories().setFrom(classDirectories.files.collect {
                fileTree(dir: it, exclude: ['**/ex/*', '**/pojo/*', '**/model/*', '**/dto/*', '**/config/*'])
            })
        }
    }

    javadoc {
        exclude("**/InternalServiceConfig#InternalServiceConfig")
        options.addStringOption('Xdoclint:none', '-quiet')
    }

    tasks.register('javadocJar', Jar) {
        dependsOn javadoc
        from javadoc.destinationDir
        archiveClassifier = 'javadoc'
        description = "Creates a Javadoc Jar for ${project.name}"
    }

    tasks.register('sourcesJar', Jar) {
        dependsOn classes
        archiveClassifier = 'sources'
        from sourceSets.main.allSource
    }

    artifacts {
        archives javadocJar, sourcesJar
    }

    publishing {
        repositories {
//            maven {
//                name = 'ossrh-staging-api'
//                if (version.endsWith("SNAPSHOT")) {
//                    url = "https://s01.oss.sonatype.org/content/repositories/snapshots"
//                } else {
//                    url = "https://ossrh-staging-api.central.sonatype.com/service/local/staging/deploy/maven2/"
//                }
//                credentials {
//                    username = rootProject.ext.artifactUsername
//                    password = rootProject.ext.artifactPassword
//                }
//            }
            maven {
                allowInsecureProtocol = true
                name = "maven-central"
                url = uri("${layout.buildDirectory.asFile.get().absolutePath}/${publishOutputFolder}")
            }
        }
        publications {
            group = group
            version = version

            mavenJava(MavenPublication) {
                from components.java
                artifact sourcesJar
                artifact javadocJar

                pom {
                    name = "Core finance ${project.name}"
                    description = "Core finance ${project.name}."
                    url = 'https://corefinance.tech/'
                    properties = [ "lib.name": "${project.name}" ]
                    licenses {
                        license {
                            name = 'The Apache License, Version 2.0'
                            url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                        }
                    }
                    developers {
                        developer {
                            id = 'dbaotrung'
                            name = 'Trung Doan'
                            email = 'doanbaotrung@gmail.com'
                        }
                    }
                    scm {
                        connection = 'scm:git:ssh://git@github.com:Open-Core-Finance/corefinance.git'
                        developerConnection = 'scm:git:ssh://git@github.com:Open-Core-Finance/corefinance.git'
                        url = 'https://github.com/Open-Core-Finance/corefinance'
                    }
                }
            }
        }
    }

    project.publish.dependsOn(project.build)
    project.publish.mustRunAfter(project.build)

    signing {
        sign publishing.publications
    }

    if (!isLib) {
        processResources {
            from("../share-resources/main-app-resources")
            include '**/*'
        }
        processTestResources {
            from("../share-resources/test-app-resources")
            include '**/*'
        }
    }

    afterEvaluate {
        dependencies {
            if (project.name != "microservice-common") {
                implementation project(":microservice-common")
            }
            if (!isLib && project.name != "jasypt-tool" && project.name != "common-feign-client") {
                // Spring boot
                implementation group: 'org.springframework.boot', name: 'spring-boot-starter-actuator'

                // Internal
                implementation project(":microservice-common-jpa")

                // Database
                implementation group: 'org.postgresql', name: 'postgresql', version: "${postgresqlVersion}"
                // implementation group: 'com.google.cloud.sql', name: 'postgres-socket-factory', version: "${gcloudPostgresSocketVersion}"

                // Test
                testImplementation 'org.springframework.boot:spring-boot-starter-test'
                testImplementation group: 'org.powermock', name: 'powermock-api-mockito2', version: "${powerMockitoVersion}"
                testImplementation group: 'com.h2database', name: 'h2', version: "${h2Version}"
                testImplementation "org.junit.jupiter:junit-jupiter:${junitVersion}"
                testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
            }
        }
    }

    tasks.register('zipPublishFiles', Zip) {
        dependsOn publish
        mustRunAfter publish
        from("${layout.buildDirectory.asFile.get().absolutePath}/${publishOutputFolder}")    // folder or files you want to zip
        archiveFileName = "${project.name}.zip"  // name of the zip file
        destinationDirectory = file("${layout.buildDirectory.asFile.get().absolutePath}") // output folder
        doLast {
            println("Published done!")
        }
    }

    tasks.register('uploadZip') {
        dependsOn zipPublishFiles
        mustRunAfter zipPublishFiles

        def zipFile = file("${layout.buildDirectory.asFile.get().absolutePath}/${project.name}.zip")
        def uploadUrl = 'https://central.sonatype.com/api/v1/publisher/upload'
        def publishingType = "PUBLISHING"
        def projectName = project.name  // gets your Gradle project name
        // Your login credentials
        def username = rootProject.ext.artifactUsername;
        def password = rootProject.ext.artifactPassword;

        doLast {
            if (!zipFile.exists()) {
                throw new GradleException("Zip file not found: $zipFile")
            }

            // Encode username:password in Base64
            def userPass = "$username:$password"
            def encoded = Base64.encoder.encodeToString(userPass.bytes)
            def bearerToken = encoded  // use this as Bearer token

            println "Using Bearer token: $bearerToken"
            // println "Username [$username] and password [$password]"

            def boundary = "===" + System.currentTimeMillis() + "==="
            def lineFeed = "\r\n"

            def url = new URI(uploadUrl).toURL()
            def connection = (HttpURLConnection) url.openConnection()
            connection.setDoOutput(true)
            connection.setRequestMethod("POST")
            connection.setRequestProperty("Content-Type", "multipart/form-data; boundary=$boundary")

            // Add Authorization header with Base64 token
            connection.setRequestProperty("Authorization", "Bearer $bearerToken")

            def outputStream = connection.getOutputStream()
            def writer = new OutputStreamWriter(outputStream, "UTF-8")

            def writeFormField = { name, value ->
                writer.write("--$boundary$lineFeed")
                writer.write("Content-Disposition: form-data; name=\"$name\"$lineFeed")
                writer.write("Content-Type: text/plain; charset=UTF-8$lineFeed")
                writer.write(lineFeed)
                writer.write(value + lineFeed)
                writer.flush()
            }

            writeFormField("publishingType", publishingType)
            writeFormField("name", projectName)

            writer.write("--$boundary$lineFeed")
            writer.write("Content-Disposition: form-data; name=\"bundle\"; filename=\"${zipFile.name}\"$lineFeed")
            writer.write("Content-Type: application/zip$lineFeed")
            writer.write(lineFeed)
            writer.flush()

            Files.copy(zipFile.toPath(), outputStream)
            outputStream.flush()

            writer.write(lineFeed)
            writer.write("--$boundary--$lineFeed")
            writer.flush()
            writer.close()

            def responseCode = connection.responseCode
            println "Response Code: $responseCode"

            def responseMessage
            try {
                responseMessage = connection.inputStream.text
            } catch (IOException e) {
                responseMessage = connection.errorStream?.text ?: "No error message"
            }
            println "Response ($responseCode): $responseMessage"

            if (responseCode >= 400) {
                throw new GradleException("Upload failed with response code $responseCode")
            }
        }
    }
}

tasks.register('clean') {
    group = 'build'
    description = 'Cleans all subprojects'

    dependsOn subprojects.collect { "${it.path}:clean" }
}

def selectedProjectsToDeploy = [":microservice-common", ":microservice-common-jpa", ":microservice-common-mongodb", "common-userprofile",
    "microservice-common-export"]

tasks.register('copyDeployFilesFromChild', Copy) {
    dependsOn selectedProjectsToDeploy.collect { project(it).tasks.named('publish') }

    selectedProjectsToDeploy.each { name ->
        def child = project(name)
        from new File(child.layout.buildDirectory.asFile.get().absolutePath, "${publishOutputFolder}")
    }

    into "${layout.buildDirectory.asFile.get().absolutePath}/${publishOutputFolder}"

    duplicatesStrategy = DuplicatesStrategy.INCLUDE

    doLast {
        println("copyDeployFilesFromChild done!")
    }
}

tasks.register('zipPublishFilesFromChilds', Zip) {
    dependsOn copyDeployFilesFromChild
    mustRunAfter copyDeployFilesFromChild
    from("${layout.buildDirectory.asFile.get().absolutePath}/${publishOutputFolder}")    // folder or files you want to zip
    archiveFileName = "${project.name}.zip"  // name of the zip file
    destinationDirectory = file("${layout.buildDirectory.asFile.get().absolutePath}") // output folder
    doLast {
        println("zipPublishFiles done!")
    }
}